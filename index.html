// === 1. ê¸°ë³¸ ë°ì´í„° ì„¤ì • ===
// ... (CHAR_COLORS, CHARACTER_NAMES, DUNGEON_DATA ë“± ë™ì¼) ...
// (ìƒëµ: ê¸°ì¡´ ì½”ë“œì™€ ë™ì¼)

    const CHAR_COLORS = {
        'ì—˜ë¦¬ì‹œìŠ¤': '#ff0000', 'ë¦¬ë¥´': '#9acd32', 'ì•„ë¥´ë©”': '#a020f0', 'ë¼ìŠ¤': '#87ceeb',
        'ë¼ì´ì–¸': '#008000', 'ë¡œë‚œ': '#4169e1', 'ì—ì´ë¯¸': '#ff69b4', 'ì§„': '#ff4500', 
        'ì§€í¬í•˜íŠ¸': '#000000', 'ë§ˆë¦¬': '#0000ff', 'ë””ì˜¤': '#800080', 'ì œë¡œ': '#3cb371', 
        'ë ˆì´': '#8a2be2', 'ë£¨í¼ìŠ¤': '#b22222', 'ë² ì´ê°€ìŠ¤': '#483d8b', 'ë¦°': '#808080', 
        'ì•„ì‹ ': '#00bfff', 'ë¼ì„': '#32cd32', 'ì—ë¸': '#4169e1', 'ë°ì¹´ë„¤': '#00ffff', 
        'ì•„ì´': '#afeeee', 'ì¹¼ë¦¬ì•„': '#c71585', 'ìš°ë…¸': '#008b8b', 'ì´ë¦¬ìŠ¤': '#add8e6'
    };

    let CHARACTER_NAMES = [
        'ì—˜ë¦¬ì‹œìŠ¤', 'ë¦¬ë¥´', 'ì•„ë¥´ë©”', 'ë¼ìŠ¤', 'ë¼ì´ì–¸', 'ë¡œë‚œ', 'ì—ì´ë¯¸', 'ì§„', 'ì§€í¬í•˜íŠ¸', 'ë§ˆë¦¬', 
        'ë””ì˜¤', 'ì œë¡œ', 'ë ˆì´', 'ë£¨í¼ìŠ¤', 'ë² ì´ê°€ìŠ¤', 'ë¦°', 'ì•„ì‹ ', 'ë¼ì„', 'ì—ë¸', 'ë°ì¹´ë„¤', 
        'ì•„ì´', 'ì¹¼ë¦¬ì•„', 'ìš°ë…¸', 'ì´ë¦¬ìŠ¤'
    ];
    
    // ë˜ì „ ë°ì´í„°
    const DUNGEON_DATA = {
        daily: [
            { id: 'berkas', name: 'ë² ë¥´ì¹´ìŠ¤ì˜ ìš”ìƒˆ', max: 1, shared: false },
            { id: 'tower', name: 'ì†Œë©¸ì˜ íƒ‘', max: 3, shared: false },
            { id: 'tero', name: 'ì´ì„¸ê³„: í…Œë¡œì¹´ ê³µì„±ì „', max: 1, shared: false },
            { id: 'temple', name: 'ì´ì„¸ê³„: ì‹œê°„ì˜ ì‚¬ì›', max: 1, shared: false },
            { id: 'kounat', name: 'ì´ì„¸ê³„: ì½”ìš°ë‚˜íŠ¸ ëŒ€í­ë°œ', max: 1, shared: false },
            { id: 'corridor', name: 'ë¬´í•œíšŒë‘', max: 3, type: 'daily', shared: true }
        ],
        weekly: [
            { id: 'judge', name: 'ì‹¬íŒì˜ ë•…', max: 3, shared: false },
            { id: 'abyss', name: 'ì‹¬ì—°ì˜ ê¸¸', max: 1, shared: false },
            { id: 'void_mon', name: 'ê³µí—ˆ ì¹¨ê³µ', max: 1, shared: false, sub: 'ì›”' }, 
            { id: 'void_wed', name: 'ê³µí—ˆ ì ì‹', max: 1, shared: false, sub: 'ìˆ˜' }, 
            { id: 'void_fri', name: 'ê³µí—ˆ ì•…ëª½', max: 1, shared: false, sub: 'ê¸ˆ' }, 
            { id: 'w_furnace', name: 'ì§€ì˜¥ì˜ ìš©ê´‘ë¡œ', max: 3, shared: false },
            { id: 'w_sanctum', name: 'íŒŒë©¸ì˜ ì„±ì†Œ', max: 3, shared: false },
            { id: 'w_laby', name: 'í™˜ì˜ì˜ ë¯¸ê¶', max: 5, shared: false }
        ]
    };
    
    let characters = []; 
    let currentChrId = null; 
    let draggedElement = null; 
    let FAVORITE_NAMES = [];
    let isFilterActive = false; 
    
    // ìº˜ë¦°ë” ë°ì´í„° ê´€ë ¨ ë³€ìˆ˜
    let CALENDAR_PROGRESS = {}; // { 'YYYY-MM-DD': { daily: { charName: percent, ... }, weekly: percent } }
    let currentCalendarDate = new Date(); 


    // === 2. ë³´ì¡° í•¨ìˆ˜ ===
    
    function getTextColor(hexColor) { 
        const r = parseInt(hexColor.substring(1, 3), 16);
        const g = parseInt(hexColor.substring(3, 5), 16);
        const b = parseInt(hexColor.substring(5, 7), 16);
        const luminance = (0.2126 * r + 0.7152 * g + 0.0722 * b) / 255;
        return luminance > 0.5 ? '#000000' : '#ffffff';
    }
    
    /**
     * ë‚ ì§œ ê°ì²´ë¥¼ YYYY-MM-DD í˜•ì‹ì˜ ë¬¸ìì—´ë¡œ ë³€í™˜
     * @param {Date} date 
     * @returns {string} YYYY-MM-DD
     */
    function formatDate(date) {
        const d = new Date(date);
        let month = '' + (d.getMonth() + 1);
        let day = '' + d.getDate();
        const year = d.getFullYear();

        if (month.length < 2) month = '0' + month;
        if (day.length < 2) day = '0' + day;

        return [year, month, day].join('-');
    }

    // === 3. ë°ì´í„° ë¡œì§ (ì´ˆê¸°í™” ë° ë¡œë“œ) ===

    const getTaskMaxCount = (taskId) => {
        let item = DUNGEON_DATA.daily.find(d => d.id === taskId);
        if (!item) item = DUNGEON_DATA.weekly.find(d => d.id === taskId);
        return item ? item.max : 1;
    };

    const getAccountSharedTaskStatus = (id) => {
        const saved = localStorage.getItem(`shared_${id}`);
        return saved ? JSON.parse(saved) : { completed: 0, max: getTaskMaxCount(id) };
    };

    const setAccountSharedTaskStatus = (id, status) => {
        localStorage.setItem(`shared_${id}`, JSON.stringify(status));
    };

    const generateInitialTasks = (type) => {
        const tasks = {};
        DUNGEON_DATA[type].filter(d => !d.shared).forEach(d => {
            tasks[d.id] = { completed: 0, max: d.max };
        });
        return tasks;
    };

    // ìºë¦­í„°ë³„ ì¼ì¼/ì£¼ê°„ ìˆ™ì œ ìƒíƒœ ê³„ì‚° (í†µê³„ ê³„ì‚° í•¨ìˆ˜)
    function calculateCharStats(char, type) {
        let totalCount = 0;
        let completedCount = 0;
        
        DUNGEON_DATA[type].filter(d => !d.shared).forEach(d => {
            // ì•ˆì „í•œ ì ‘ê·¼ì„ ìœ„í•´ ì´ˆê¸°í™”ë˜ì§€ ì•Šì€ taskëŠ” 0ìœ¼ë¡œ ì²˜ë¦¬ (ë°©ì–´ ì½”ë“œ)
            const status = char[`${type}Tasks`][d.id] || { completed: 0, max: d.max }; 
            totalCount += status.max;
            completedCount += status.completed;
        });
        
        const percentage = totalCount > 0 ? Math.floor((completedCount / totalCount) * 100) : 100;
        
        return { totalCount, completedCount, percentage };
    }
    
    // ìº˜ë¦°ë” ì €ì¥ì„ ìœ„í•œ í˜„ì¬ ì§„í–‰ ìƒí™© ìˆ˜ì§‘
    function collectCurrentProgress() {
        const dailyProgress = {};
        let weeklyTotalPercent = 0;
        let weeklyCharCount = 0;
        
        FAVORITE_NAMES.forEach(name => {
            const char = characters.find(c => c.name === name);
            if (char) {
                dailyProgress[name] = char.dailyStats.percentage;
                weeklyTotalPercent += char.weeklyStats.percentage;
                weeklyCharCount++;
            }
        });
        
        // ê³„ì • ê³µìœ  ì¼ì¼ ìˆ™ì œ í¬í•¨
        const sharedDaily = DUNGEON_DATA.daily.find(d => d.shared && d.id === 'corridor');
        const sharedStatus = sharedDaily ? getAccountSharedTaskStatus(sharedDaily.id) : { completed: 0, max: 0 };
        const sharedDailyPercent = sharedStatus.max > 0 ? Math.floor((sharedStatus.completed / sharedStatus.max) * 100) : 100;
        
        // ì£¼ê°„ ì „ì²´ í‰ê· 
        const weeklyAverage = weeklyCharCount > 0 ? Math.floor(weeklyTotalPercent / weeklyCharCount) : 100;

        return {
            daily: dailyProgress, // ì¦ê²¨ì°¾ê¸° ìºë¦­í„°ë³„ ì¼ì¼ ì™„ë£Œìœ¨
            dailyShared: sharedDailyPercent, // ê³„ì • ê³µìœ  ì¼ì¼ ì™„ë£Œìœ¨
            weekly: weeklyAverage // ì¦ê²¨ì°¾ê¸° ìºë¦­í„° ì£¼ê°„ í‰ê·  ì™„ë£Œìœ¨
        };
    }
    
    // ì¼ì¼ ì§„ì²™ë„ ì €ì¥ í•¨ìˆ˜
    function saveDailyProgress(dateKey) {
        const progress = collectCurrentProgress();
        
        // ë‹¹ì¼ ë°ì´í„°ê°€ ì´ë¯¸ ìˆìœ¼ë©´ ì—…ë°ì´íŠ¸ (ì‹¤ì‹œê°„ ë°˜ì˜)
        // ë‹¹ì¼ ë°ì´í„°ê°€ ì—†ìœ¼ë©´ ìƒˆë¡œ ì €ì¥
        CALENDAR_PROGRESS[dateKey] = progress;
        localStorage.setItem('gc_calendar_progress', JSON.stringify(CALENDAR_PROGRESS));
    }
    
    /**
     * ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì—ì„œ ë°ì´í„°ë¥¼ ì½ì–´ì™€ ì „ì—­ ë³€ìˆ˜ë¥¼ ì´ˆê¸°í™”í•˜ê³  ë¦¬ì…‹ ì—¬ë¶€ë¥¼ ì²´í¬
     */
    function initializeVariables() {
        // ê¸°ì¡´ ìºë¦­í„°/ìˆœì„œ/ì¦ê²¨ì°¾ê¸° ë¡œë“œ
        const savedOrder = localStorage.getItem('characterOrder');
        if (savedOrder) {
            const savedNames = JSON.parse(savedOrder);
            const newNames = CHARACTER_NAMES.filter(name => !savedNames.includes(name));
            CHARACTER_NAMES = [...savedNames, ...newNames];
        }
        
        const savedFavorites = localStorage.getItem('favoriteCharacters');
        FAVORITE_NAMES = savedFavorites ? JSON.parse(savedFavorites).filter(name => CHARACTER_NAMES.includes(name)) : [];
        isFilterActive = localStorage.getItem('isFilterActive') === 'true'; 

        const savedData = localStorage.getItem('gc_characters');
        const lastReset = localStorage.getItem('lastResetTime');

        const existingIds = savedData ? JSON.parse(savedData).map(c => c.id) : [];
        let nextId = existingIds.length > 0 ? Math.max(...existingIds) + 1 : 1;
        const charMap = new Map(savedData ? JSON.parse(savedData).map(c => [c.name, c]) : []);

        characters = CHARACTER_NAMES.map(name => {
            let char = charMap.get(name);
            
            if (!char) {
                char = {
                    id: nextId++,
                    name: name,
                    dailyTasks: generateInitialTasks('daily'),
                    weeklyTasks: generateInitialTasks('weekly')
                };
            }
            
            const updatedChar = { ...char };
            
            updatedChar.dailyTasks = updatedChar.dailyTasks || generateInitialTasks('daily');
            updatedChar.weeklyTasks = updatedChar.weeklyTasks || generateInitialTasks('weekly');
            
            return updatedChar;
        });
        
        // ìº˜ë¦°ë” ë°ì´í„° ë¡œë“œ
        const savedCalendar = localStorage.getItem('gc_calendar_progress');
        CALENDAR_PROGRESS = savedCalendar ? JSON.parse(savedCalendar) : {};
        
        // ë¦¬ì…‹ ì²´í¬ ë° ì ìš© (ë°ì´í„°ë¥¼ ë¡œì»¬ì— ì €ì¥í•˜ì§€ ì•ŠìŒ, ì•„ë˜ checkResetAndRenderì—ì„œ ì¼ê´„ ì²˜ë¦¬)
        checkAndApplyReset(characters, lastReset, false); 
        
        // í†µê³„ ê³„ì‚°
        characters.forEach(char => {
            const dailyStats = calculateCharStats(char, 'daily');
            const weeklyStats = calculateCharStats(char, 'weekly');
            char.dailyStats = dailyStats;
            char.weeklyStats = weeklyStats;
            char.hasIncompleteDaily = dailyStats.totalCount > dailyStats.completedCount;
            char.hasIncompleteWeekly = weeklyStats.totalCount > weeklyStats.completedCount;
        });
        
        // ìºë¦­í„° ë°ì´í„°ëŠ” checkAndApplyResetì—ì„œ ì—…ë°ì´íŠ¸í–ˆì„ ê²½ìš°ì—ë§Œ ì €ì¥
        // initializeVariablesì—ì„œëŠ” ë³€ìˆ˜ ì´ˆê¸°í™”ë§Œ ë‹´ë‹¹
        currentChrId = localStorage.getItem('currentChrId') || (characters.length > 0 ? characters[0].id : null);
    }
    
    /**
     * ë¦¬ì…‹ì´ í•„ìš”í•œì§€ í™•ì¸í•˜ê³ , í•„ìš”í•˜ë‹¤ë©´ ì ìš©
     * @param {Array} currentChars - í˜„ì¬ ìºë¦­í„° ë°ì´í„°
     * @param {string} lastResetTime - ë§ˆì§€ë§‰ ë¦¬ì…‹ ì‹œê°„ (ISO string)
     * @param {boolean} shouldSave - ë¦¬ì…‹ ì ìš© í›„ ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ì €ì¥í• ì§€ ì—¬ë¶€
     */
    function checkAndApplyReset(currentChars, lastResetTime, shouldSave = true) { 
        const now = new Date();
        const dailyResetHour = 15;
        const weeklyResetDay = 3; 

        const kstNow = new Date(now.toLocaleString("en-US", { timeZone: "Asia/Seoul" }));
        
        let shouldResetDaily = false;
        let shouldResetWeekly = false;
        
        let lastResetKST = null;
        if (lastResetTime) {
            const lastReset = new Date(lastResetTime);
            lastResetKST = new Date(lastReset.toLocaleString("en-US", { timeZone: "Asia/Seoul" }));
        }

        // --- ì¼ì¼ ì´ˆê¸°í™” í™•ì¸ ---
        const todayKey = formatDate(kstNow);
        let lastDailyCheckTime = lastResetKST ? new Date(lastResetKST) : new Date(0); 
        
        let nextDailyReset = new Date(lastDailyCheckTime);
        nextDailyReset.setHours(dailyResetHour, 0, 0, 0);

        if (lastDailyCheckTime.getHours() >= dailyResetHour) {
            nextDailyReset.setDate(nextDailyReset.getDate() + 1);
        }

        if (kstNow.getTime() >= nextDailyReset.getTime()) {
            shouldResetDaily = true;
            
            // ìº˜ë¦°ë” ì§„ì²™ë„ ì €ì¥: ë¦¬ì…‹ëœ ë‚ ì§œì˜ ì „ë‚  ë°ì´í„°(ì¦‰, ë¦¬ì…‹ ì§ì „ì˜ ë°ì´í„°)ë¥¼ ì €ì¥
            const dateToSave = new Date(nextDailyReset);
            dateToSave.setDate(dateToSave.getDate() - 1);
            
            // ë¦¬ì…‹ ì§ì „ì—ë§Œ ì§„ì²™ë„ë¥¼ ì €ì¥
            if (shouldSave) {
                 // ë¦¬ì…‹ë˜ê¸° ì „ ë§ˆì§€ë§‰ ë°ì´í„°ë¥¼ ì €ì¥
                saveDailyProgress(formatDate(dateToSave)); 
            }
        }
        
        // --- ì£¼ê°„ ì´ˆê¸°í™” í™•ì¸ ---
        let lastWeeklyCheckTime = lastResetKST ? new Date(lastResetKST) : new Date(0); 

        let currentCheckTime = new Date(lastWeeklyCheckTime);
        currentCheckTime.setHours(dailyResetHour, 0, 0, 0);
        
        let nextWeeklyReset = new Date(currentCheckTime);

        while (nextWeeklyReset.getDay() !== weeklyResetDay || nextWeeklyReset.getTime() <= currentCheckTime.getTime()) {
            nextWeeklyReset.setDate(nextWeeklyReset.getDate() + 1);
            nextWeeklyReset.setHours(dailyResetHour, 0, 0, 0);
        }

        if (kstNow.getTime() >= nextWeeklyReset.getTime()) {
            shouldResetWeekly = true;
        }


        // --- ë¦¬ì…‹ ì ìš© ë° ì €ì¥ ---
        if (shouldResetDaily) {
            currentChars.forEach(char => {
                char.dailyTasks = generateInitialTasks('daily');
            });
            setAccountSharedTaskStatus('corridor', { completed: 0, max: getTaskMaxCount('corridor') });
        }

        if (shouldResetWeekly) {
            currentChars.forEach(char => {
                char.weeklyTasks = generateInitialTasks('weekly');
            });
        }
        
        if (shouldResetDaily || shouldResetWeekly) {
            // ë¦¬ì…‹ì´ ë°œìƒí•˜ë©´ ë§ˆì§€ë§‰ ë¦¬ì…‹ ì‹œê°„ì„ í˜„ì¬ KST ì‹œê°„ìœ¼ë¡œ ì—…ë°ì´íŠ¸
            if (shouldSave) {
                localStorage.setItem('lastResetTime', kstNow.toISOString());
                localStorage.setItem('gc_characters', JSON.stringify(currentChars));
            }
            return true;
        }
        
        // í˜„ì¬ ë‚ ì§œ ì§„ì²™ë„ëŠ” ë¦¬ì…‹ ì²´í¬ì™€ ê´€ê³„ì—†ì´ í•­ìƒ ì‹¤ì‹œê°„ìœ¼ë¡œ ì—…ë°ì´íŠ¸
        if (shouldSave) {
            saveDailyProgress(todayKey); 
        }

        return false;
    }

    /**
     * ì£¼ê¸°ì ìœ¼ë¡œ ë¦¬ì…‹ì„ ì²´í¬í•˜ê³ , ë¦¬ì…‹ì´ ë°œìƒí•˜ë©´ ì „ì²´ UIë¥¼ ë Œë”ë§
     */
    function checkResetAndRender() {
        const lastReset = localStorage.getItem('lastResetTime');
        
        // ì„ì‹œ ë°°ì—´ì„ ë§Œë“¤ì–´ ë¦¬ì…‹ ì²´í¬. ì‹¤ì œ ìºë¦­í„° ë°°ì—´ì€ initializeVariablesì—ì„œ ë¡œë“œëœ ì „ì—­ ë°°ì—´
        let tempCharacters = JSON.parse(localStorage.getItem('gc_characters'));
        if (!tempCharacters) {
            // ë°ì´í„°ê°€ ì—†ìœ¼ë©´ ë‹¤ì‹œ ë¡œë“œ
            render(); 
            return;
        }

        const resetOccurred = checkAndApplyReset(tempCharacters, lastReset, true);
        
        if (resetOccurred) {
            render();
        } else {
             // ë¦¬ì…‹ì´ ë°œìƒí•˜ì§€ ì•Šì•˜ë”ë¼ë„ ìº˜ë¦°ë”ì˜ ì˜¤ëŠ˜ ë‚ ì§œëŠ” ì‹¤ì‹œê°„ìœ¼ë¡œ ê°±ì‹ 
            if (document.getElementById('calendar-modal').style.display === 'flex') {
                renderCalendar();
            }
        }
    }


    // === 4. í†µê³„ ë° í•„í„° ë¡œì§ ===

    // ... (updateAccountStats, toggleFilter, updateFilterButton ë“± ë™ì¼) ...
    function updateAccountStats() {
        // í†µê³„ ê³„ì‚° ë¡œì§ ìœ ì§€
        let totalDaily = 0;
        let doneDaily = 0;
        let totalWeekly = 0;
        let doneWeekly = 0;

        characters.forEach(char => {
            totalDaily += char.dailyStats.totalCount;
            doneDaily += char.dailyStats.completedCount;
            totalWeekly += char.weeklyStats.totalCount;
            doneWeekly += char.weeklyStats.completedCount;
        });

        const sharedDaily = DUNGEON_DATA.daily.find(d => d.shared && d.id === 'corridor');
        if (sharedDaily) {
            const sharedStatus = getAccountSharedTaskStatus(sharedDaily.id);
            totalDaily += sharedStatus.max;
            doneDaily += sharedStatus.completed;
        }
    }

    function toggleFilter() {
        isFilterActive = !isFilterActive;
        localStorage.setItem('isFilterActive', isFilterActive);
        render();
    }
    
    function updateFilterButton() {
        const button = document.getElementById('filter-toggle-btn');
        if (isFilterActive) {
            button.classList.add('active');
        } else {
            button.classList.remove('active');
        }
    }

    // === 5. DND ë° ìˆ™ì œ í•¸ë“¤ëŸ¬ ===
    
    // ... (handleDragStart, handleDragOver, handleDragLeave, handleDropToFavorite, handleDrop, handleDragEnd, removeFavorite, selectCharacter í•¨ìˆ˜ëŠ” ë³€ê²½ ì—†ìŒ) ...
    // (ìƒëµ: ê¸°ì¡´ ì½”ë“œì™€ ë™ì¼)

    function selectCharacter(id) {
        currentChrId = id;
        localStorage.setItem('currentChrId', id);
        render(); 
    }
    
    function toggleAllTasks(type, taskId, currentStatus) {
        const item = DUNGEON_DATA[type].find(d => d.id === taskId);
        if (!item || item.shared) return; 

        const newCount = currentStatus ? item.max : 0; 
        
        characters.forEach(char => {
            char[`${type}Tasks`][taskId] = { completed: newCount, max: item.max };
        });

        localStorage.setItem('gc_characters', JSON.stringify(characters));
        
        characters.forEach(char => {
            char.dailyStats = calculateCharStats(char, 'daily');
            char.weeklyStats = calculateCharStats(char, 'weekly');
            char.hasIncompleteDaily = char.dailyStats.totalCount > char.dailyStats.completedCount;
            char.hasIncompleteWeekly = char.weeklyStats.totalCount > char.weeklyStats.completedCount;
        });

        // ì¼ê´„ ë³€ê²½ ì‹œ í˜„ì¬ ì§„í–‰ ìƒí™©ì„ ìº˜ë¦°ë” ë°ì´í„°ì—ë„ ì¦‰ì‹œ ë°˜ì˜
        const todayKey = formatDate(new Date());
        saveDailyProgress(todayKey); 

        render();
    }
    
    function toggleTask(chrId, type, taskId, shared) { 
        const item = DUNGEON_DATA[type].find(d => d.id === taskId);
        
        if (shared) {
            const status = getAccountSharedTaskStatus(taskId);
            const newCount = status.completed === 0 ? item.max : 0; 
            setAccountSharedTaskStatus(taskId, { completed: newCount, max: item.max });
        } else {
            const charIndex = characters.findIndex(c => c.id === chrId);
            if (charIndex === -1) return;
    
            const char = characters[charIndex];
            const currentCount = char[`${type}Tasks`][taskId].completed;
            
            const newCount = currentCount === 0 ? item.max : 0;
            
            char[`${type}Tasks`][taskId].completed = newCount;
            localStorage.setItem('gc_characters', JSON.stringify(characters));
        }
        
        const char = characters.find(c => c.id === chrId);
        if (char) {
            char.dailyStats = calculateCharStats(char, 'daily');
            char.weeklyStats = calculateCharStats(char, 'weekly');
            char.hasIncompleteDaily = char.dailyStats.totalCount > char.dailyStats.completedCount;
            char.hasIncompleteWeekly = char.weeklyStats.totalCount > char.weeklyStats.completedCount;
        }

        // ê°œë³„ ë³€ê²½ ì‹œ í˜„ì¬ ì§„í–‰ ìƒí™©ì„ ìº˜ë¦°ë” ë°ì´í„°ì—ë„ ì¦‰ì‹œ ë°˜ì˜
        const todayKey = formatDate(new Date());
        saveDailyProgress(todayKey); 

        render();
    }
    
    // ... (handleDragStart, handleDragOver, handleDragLeave, handleDropToFavorite, handleDrop, handleDragEnd, removeFavorite í•¨ìˆ˜ëŠ” ë³€ê²½ ì—†ìŒ) ...
    // (ìƒëµ: ê¸°ì¡´ ì½”ë“œì™€ ë™ì¼)

    // === 6. ì‹œê°„ ë° í…Œë§ˆ ë¡œì§ ===
    
    function updateCurrentTime() { 
        // ê¸°ì¡´ê³¼ ë™ì¼
        const now = new Date();
        const rawString = now.toLocaleString("ko-KR", { 
            timeZone: "Asia/Seoul", 
            year: 'numeric', 
            month: '2-digit', 
            day: '2-digit', 
            weekday: 'short', 
            hour: '2-digit', 
            minute: '2-digit', 
            hour12: false 
        });
        
        let finalFormattedTime = rawString.replace(/^(\d{4})\.\s(\d{2})\.\s/, (match, year, month) => {
            return `${year}.${month}. `;
        });
        
        document.getElementById('current-time-display').innerText = finalFormattedTime;
    }

    const getTheme = () => localStorage.getItem('theme') || 'dark';

    function setTheme(theme) { 
        document.body.className = theme === 'dark' ? 'dark-mode' : 'light-mode';
        localStorage.setItem('theme', theme);
        updateThemeToggleText(theme);
    }
    
    function toggleTheme() { 
        const currentTheme = getTheme();
        setTheme(currentTheme === 'dark' ? 'light' : 'dark');
    }

    function updateThemeToggleText(theme) {
        const button = document.getElementById('theme-toggle');
        button.innerText = theme === 'dark' ? 'â˜€ï¸ ë‚® ëª¨ë“œ' : 'ğŸŒ™ ë°¤ ëª¨ë“œ';
    }

    // === 7. ìº˜ë¦°ë” ë¡œì§ ===
    
    function openCalendar() {
        document.getElementById('calendar-modal').style.display = 'flex';
        renderCalendar();
    }

    function closeCalendar() {
        document.getElementById('calendar-modal').style.display = 'none';
    }
    
    function closeModalOutside(event) {
        if (event.target === document.getElementById('calendar-modal')) {
            closeCalendar();
        }
    }
    
    function changeMonth(delta) {
        currentCalendarDate.setMonth(currentCalendarDate.getMonth() + delta);
        renderCalendar();
    }

    function renderCalendar() {
        const date = currentCalendarDate;
        const year = date.getFullYear();
        const month = date.getMonth(); 

        document.getElementById('calendar-title').innerText = `${year}ë…„ ${month + 1}ì›”`;

        const grid = document.getElementById('calendar-grid');
        while (grid.children.length > 7) {
            grid.removeChild(grid.lastChild);
        }

        const firstDay = new Date(year, month, 1);
        const lastDay = new Date(year, month + 1, 0);
        
        const startDayOfWeek = firstDay.getDay(); 

        for (let i = 0; i < startDayOfWeek; i++) {
            const emptyDay = document.createElement('div');
            emptyDay.className = 'calendar-day empty';
            grid.appendChild(emptyDay);
        }

        const todayKey = formatDate(new Date());
        for (let day = 1; day <= lastDay.getDate(); day++) {
            const currentDate = new Date(year, month, day);
            const dateKey = formatDate(currentDate);

            const dayDiv = document.createElement('div');
            dayDiv.className = 'calendar-day';
            if (dateKey === todayKey) {
                dayDiv.classList.add('today');
            }
            
            const dayNumber = document.createElement('div');
            dayNumber.className = 'day-number';
            dayNumber.innerText = day;
            dayDiv.appendChild(dayNumber);
            
            const progressContainer = document.createElement('div');
            progressContainer.className = 'progress-indicator-container';
            
            // ì˜¤ëŠ˜ ë‚ ì§œì´ê±°ë‚˜, ì €ì¥ëœ ë°ì´í„°ê°€ ìˆëŠ” ê²½ìš°ì—ë§Œ í‘œì‹œ
            const progressData = CALENDAR_PROGRESS[dateKey] || 
                                 (dateKey === todayKey ? collectCurrentProgress() : null);

            if (progressData) {
                // 1. ì¼ì¼ ì§„ì²™ë„ (ì¦ê²¨ì°¾ê¸° ìºë¦­í„°ë³„)
                const dailyContainer = document.createElement('div');
                dailyContainer.className = 'daily-progress';
                
                FAVORITE_NAMES.forEach(name => {
                    const percent = progressData.daily[name] !== undefined ? progressData.daily[name] : 100;
                    
                    let dotClass = '';
                    if (percent === 100) dotClass = 'dot-complete';
                    else if (percent === 0) dotClass = 'dot-incomplete';
                    else dotClass = 'dot-partial';
                    
                    const dot = document.createElement('span');
                    dot.className = `daily-progress-dot ${dotClass}`;
                    dot.title = `${name}: ${percent}%`;
                    dailyContainer.appendChild(dot);
                });

                // ê³„ì • ê³µìœ  ì¼ì¼ ìˆ™ì œ í¬í•¨
                const sharedPercent = progressData.dailyShared !== undefined ? progressData.dailyShared : 100;
                let sharedDotClass = '';
                if (sharedPercent === 100) sharedDotClass = 'dot-complete';
                else if (sharedPercent === 0) sharedDotClass = 'dot-incomplete';
                else sharedDotClass = 'dot-partial';
                
                const sharedDot = document.createElement('span');
                sharedDot.className = `daily-progress-dot ${sharedDotClass}`;
                sharedDot.title = `ë¬´í•œíšŒë‘(ê³µìœ ): ${sharedPercent}%`;
                dailyContainer.appendChild(sharedDot);
                
                progressContainer.appendChild(dailyContainer);

                // 2. ì£¼ê°„ ì§„ì²™ë„ (ì¦ê²¨ì°¾ê¸° í‰ê· )
                const weeklyPercent = progressData.weekly;
                const weeklyDiv = document.createElement('div');
                let weeklyClass = '';
                let weeklyText = '';
                
                if (weeklyPercent === 100) {
                    weeklyClass = 'weekly-complete';
                    weeklyText = 'ì£¼ê°„ ALL';
                } else if (weeklyPercent > 0) {
                    weeklyClass = 'weekly-partial';
                    weeklyText = `ì£¼ê°„ ${weeklyPercent}%`;
                } else {
                    weeklyClass = 'weekly-incomplete';
                    weeklyText = 'ì£¼ê°„ 0%';
                }
                
                weeklyDiv.className = `weekly-progress ${weeklyClass}`;
                weeklyDiv.innerText = weeklyText;
                
                progressContainer.appendChild(weeklyDiv);
            }

            dayDiv.appendChild(progressContainer);
            grid.appendChild(dayDiv);
        }
    }


    // === 8. í™”ë©´ ë Œë”ë§ ===

    function renderCharacterSelector() {
        // ... (ìƒëµ: ê¸°ì¡´ ì½”ë“œì™€ ë™ì¼)
        const allSelector = document.getElementById('character-selector');
        const favList = document.getElementById('favorite-list');
        
        allSelector.innerHTML = '';
        favList.innerHTML = '';

        const renderedFavorites = FAVORITE_NAMES.map(name => createCharButton(name, true)).filter(Boolean);
        
        if (renderedFavorites.length > 0) {
            renderedFavorites.forEach(btn => favList.appendChild(btn));
        } else {
            favList.innerHTML = '<span class="favorite-list-placeholder">ìºë¦­í„°ë¥¼ ì—¬ê¸°ì— ë“œë˜ê·¸í•˜ì„¸ìš”.</span>';
        }

        let filteredCharacterNames = CHARACTER_NAMES;
        
        if (isFilterActive) {
            filteredCharacterNames = CHARACTER_NAMES.filter(name => {
                const char = characters.find(c => c.name === name);
                return char && (char.hasIncompleteDaily || char.hasIncompleteWeekly);
            });
        }
        
        filteredCharacterNames.forEach(name => {
            const button = createCharButton(name, false);
            if (button) {
                allSelector.appendChild(button);
            }
        });
    }
    
    function createCharButton(charName, isFavorite = false) {
        // ... (ìƒëµ: ê¸°ì¡´ ì½”ë“œì™€ ë™ì¼)
        const char = characters.find(c => c.name === charName);
        if (!char) return null;
        
        const charColor = CHAR_COLORS[char.name] || '#808080'; 
        const charTextColor = getTextColor(charColor);
        const dailyPer = char.dailyStats.percentage || 0;
        const weeklyPer = char.weeklyStats.percentage || 0;
        const overallPercent = dailyPer * 0.5 + weeklyPer * 0.5; 
        
        const favoriteStar = FAVORITE_NAMES.includes(charName) ? 'â­ï¸ ' : ''; 

        const button = document.createElement('button');
        button.className = `char-btn ${char.id == currentChrId ? 'active' : ''}`;
        button.setAttribute('data-char-name', char.name);
        button.onclick = () => selectCharacter(char.id);

        button.innerHTML = `
            <span>${favoriteStar}${char.name}</span>
            <div class="progress-bar-container">
                <div class="progress-bar" style="width: ${overallPercent}%;"></div>
            </div>
        `;
        
        if (char.id == currentChrId) {
            button.style.backgroundColor = charColor;
            button.style.color = charTextColor;
            button.style.fontWeight = 'bold';
            button.style.boxShadow = `0 2px 5px var(--shadow-color)`;
            button.onmouseover = null;
            button.onmouseout = null;
        } else {
            button.onmouseover = function() {
                this.style.backgroundColor = charColor;
                this.style.color = charTextColor;
                this.style.opacity = 0.8;
            };
            button.onmouseout = function() {
                this.style.backgroundColor = 'var(--bg-item)';
                this.style.color = 'var(--text-color)';
                this.style.opacity = 1;
            };
        }

        if (isFavorite) {
            button.title = "ë”ë¸” í´ë¦­ ë˜ëŠ” ë“œë˜ê·¸í•˜ì—¬ ì œê±°, ë“œë˜ê·¸ ì•¤ ë“œë¡­ìœ¼ë¡œ ìˆœì„œ ë³€ê²½";
            button.ondblclick = (e) => { 
                e.preventDefault();
                removeFavorite(char.name);
            };
        }

        button.setAttribute('draggable', true);
        button.addEventListener('dragstart', handleDragStart);
        button.addEventListener('dragover', handleDragOver);
        button.addEventListener('dragleave', handleDragLeave);
        button.addEventListener('dragend', handleDragEnd);

        return button;
    }


    function renderTaskList() {
        // ... (ìƒëµ: ê¸°ì¡´ ì½”ë“œì™€ ë™ì¼)
        const currentCharacter = characters.find(c => c.id == currentChrId);
        
        if (!currentCharacter) {
            document.getElementById('current-char-name').innerText = 'ìºë¦­í„°ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.';
            document.getElementById('task-view-container').style.display = 'none';
            document.getElementById('daily-stats-display').innerHTML = ''; 
            document.getElementById('weekly-stats-display').innerHTML = ''; 
            return;
        }
        
        document.getElementById('task-view-container').style.display = 'flex';
        const favoriteStar = FAVORITE_NAMES.includes(currentCharacter.name) ? 'â­ï¸ ' : '';
        document.getElementById('current-char-name').innerText = `í˜„ì¬ ì„ íƒ ìºë¦­í„°: [${favoriteStar}${currentCharacter.name}]`;
        
        const dailyStatsHtml = `
            <div class="stat-item">
                <span>ì¼ì¼ ì™„ë£Œìœ¨: <b>${currentCharacter.dailyStats.percentage}%</b></span>
                <div class="stat-bar-container"><div class="stat-bar" style="width: ${currentCharacter.dailyStats.percentage}%;"></div></div>
            </div>
        `;
        const weeklyStatsHtml = `
            <div class="stat-item">
                <span>ì£¼ê°„ ì™„ë£Œìœ¨: <b>${currentCharacter.weeklyStats.percentage}%</b></span>
                <div class="stat-bar-container"><div class="stat-bar" style="width: ${currentCharacter.weeklyStats.percentage}%;"></div></div>
            </div>
        `;
        
        document.getElementById('daily-stats-display').innerHTML = dailyStatsHtml;
        document.getElementById('weekly-stats-display').innerHTML = weeklyStatsHtml;

        const renderList = (type, listId) => {
            const container = document.getElementById(listId);
            container.innerHTML = '';
            
            const listToRender = DUNGEON_DATA[type];
            
            listToRender.forEach(item => {
                const isShared = item.shared || false;
                let taskStatus;
                
                if (isShared) {
                    taskStatus = getAccountSharedTaskStatus(item.id);
                } else {
                    taskStatus = currentCharacter[`${type}Tasks`][item.id] || { completed: 0, max: item.max };
                }

                const isCompleted = taskStatus.completed >= taskStatus.max;
                
                const div = document.createElement('div');
                div.onclick = () => toggleTask(currentCharacter.id, type, item.id, isShared);
                div.className = `task-item bg-${item.id} ${isCompleted ? 'done' : ''}`;

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = isCompleted;
                checkbox.onclick = (e) => {
                    e.stopPropagation(); 
                    toggleTask(currentCharacter.id, type, item.id, isShared);
                };
                
                const labelGroup = document.createElement('div');
                labelGroup.className = 'task-label-group';
                
                const label = document.createElement('span');
                label.className = 'task-label';
                label.innerText = item.name;
                labelGroup.appendChild(label);
                
                if (isShared) { 
                    const tag = document.createElement('span');
                    tag.className = 'task-tag shared'; 
                    tag.innerText = 'ê³„ì • ê³µìœ ';
                    labelGroup.appendChild(tag);
                }
                if (type === 'weekly' && item.sub) {
                    const tag = document.createElement('span');
                    tag.className = 'task-tag day'; 
                    tag.innerText = item.sub; 
                    labelGroup.appendChild(tag);
                }

                div.appendChild(checkbox);
                div.appendChild(labelGroup);
                
                if (!isShared) {
                    const isAllCompleted = characters.every(char => {
                        const charStatus = char[`${type}Tasks`][item.id] || { completed: 0, max: item.max };
                        return charStatus.completed >= charStatus.max;
                    });
                    
                    const allCharContainer = document.createElement('div');
                    allCharContainer.className = 'all-char-check-container';
                    
                    const allCharCheckbox = document.createElement('input');
                    allCharCheckbox.type = 'checkbox';
                    allCharCheckbox.checked = isAllCompleted;
                    allCharCheckbox.id = `all_char_${type}_${item.id}`;
                    
                    allCharCheckbox.onclick = (e) => {
                        e.stopPropagation(); 
                        toggleAllTasks(type, item.id, !isAllCompleted); 
                    };
                    
                    const allCharLabel = document.createElement('label');
                    allCharLabel.htmlFor = allCharCheckbox.id;
                    allCharLabel.innerText = 'ì¼ê´„ ì™„ë£Œ';
                    
                    allCharContainer.appendChild(allCharLabel);
                    allCharContainer.appendChild(allCharCheckbox);
                    
                    div.appendChild(allCharContainer);
                    
                    allCharContainer.onclick = (e) => e.stopPropagation();
                }


                container.appendChild(div);
            });
        };

        renderList('daily', 'daily-list');
        renderList('weekly', 'weekly-list');
    }
    
    function render() {
        // ë°ì´í„° ë¡œì»¬ì—ì„œ ë¶ˆëŸ¬ì™€ ë³€ìˆ˜ ì´ˆê¸°í™” ë° í†µê³„ ê³„ì‚°
        initializeVariables(); 
        
        renderCharacterSelector(); 
        renderTaskList(); 
        updateAccountStats(); 
        updateFilterButton(); 
        updateCurrentTime(); 
        
        if (document.getElementById('calendar-modal').style.display === 'flex') {
            renderCalendar();
        }
    }

    // === 9. ì‹œì‘ ë° ì£¼ê¸°ì  ì²´í¬ ===
    
    setTheme(getTheme()); 
    render(); 
    
    // 1ë¶„ë§ˆë‹¤ ë¦¬ì…‹ë§Œ ì²´í¬í•˜ê³ , ë¦¬ì…‹ì´ ë°œìƒí–ˆì„ ë•Œë§Œ UI ì „ì²´ë¥¼ ë Œë”ë§
    setInterval(checkResetAndRender, 60000); 
    // 1ì´ˆë§ˆë‹¤ í˜„ì¬ ì‹œê°„ ì—…ë°ì´íŠ¸
    setInterval(updateCurrentTime, 1000); 

</script>
